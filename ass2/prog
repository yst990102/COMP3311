#!/usr/bin/python3
# COMP3311 21T3 Ass2 ... progression check for a given student

import sys
import psycopg2
import re
from helpers import Grade_in_UOC, Print_Xuoc, Print_fail, getBasicProgramInfo, getBasicStreamInfo, getCompletedSubjects, getProgramRules, getProgramStreamTableByZid, getStreamRules, getStudent, getProgram, getStream, getNameByZid

# define any local helper functions here
debug = 1


### set up some globals

usage = f"Usage: {sys.argv[0]} zID [Program Stream]"
db = None

### process command-line args

argc = len(sys.argv)
if argc < 2:
	print(usage)
	exit(1)
zid = sys.argv[1]
if zid[0] == 'z':
	zid = zid[1:8]
digits = re.compile("^\d{7}$")
if not digits.match(zid):
	print("Invalid student ID")
	exit(1)

progCode = None
strmCode = None

if argc == 4:
	progCode = sys.argv[2]
	strmCode = sys.argv[3]

# manipulate database

try:
	db = psycopg2.connect(dbname="mymyunsw",user="yst990102",password="zxcvb987321",port="6000")
	stuInfo = getStudent(db,zid)
	if not stuInfo:
		print(f"Invalid student id {zid}")
		exit()
	#print(stuInfo)
	[family_name , given_name] = getNameByZid(db, zid)[1:]
	print(f"{zid} {family_name}, {given_name}")

	if progCode:
		progInfo = getProgram(db,progCode)
		if not progInfo:
			print(f"Invalid program code {progCode}")
			exit()

	if strmCode:
		strmInfo = getStream(db,strmCode)
		if not strmInfo:
			print(f"Invalid program code {strmCode}")
			exit()

	# if have a program/stream
	#   show progression check on supplied program/stream
	# else
	#   show progression check on most recent program/stream enrolment

	if progCode and strmCode:
		program = progCode
		stream = strmCode
	else:
		prog_strm_table = getProgramStreamTableByZid(db, zid)
		latest_prog_strm = prog_strm_table[-1]
		program = latest_prog_strm[1]
		stream = latest_prog_strm[2]

	program_name = getBasicProgramInfo(db,program)[1]
	stream_name = getBasicStreamInfo(db, stream)[1]

	print(f"  {program} {program_name}")
	print(f"  {stream} {stream_name}")

	rules = {}
	# get program rules
	program_rules = getProgramRules(db, program)
	formated_program_rules = []
	for program_rule in program_rules:
		formated_program_rule = list(program_rule)[:-1]

		splited_requirements = program_rule[-1].split(",")
		formated_requirements = []
		for i in splited_requirements:
			i = i.replace('{', '["')
			i = i.replace('}', '"]')
			i = i.replace(';', '","')
			if '[' in i and ']' in i:
				formated_requirements.append(eval(i))
			elif '#' in i:
				formated_requirements.append(re.sub('#', '.', i))
			else:
				formated_requirements.append(i)
  
		formated_program_rule.append(formated_requirements)
		formated_program_rules.append(formated_program_rule)
	rules[program] = formated_program_rules

	# get stream rules
	stream_rules = getStreamRules(db, stream)
	formated_stream_rules = []
	for stream_rule in stream_rules:
		formated_stream_rule = list(stream_rule)[:-1]

		splited_requirements = stream_rule[-1].split(",")
		formated_requirements = []
		for i in splited_requirements:
			i = i.replace('{', '["')
			i = i.replace('}', '"]')
			i = i.replace(';', '","')
			if '[' in i and ']' in i:
				formated_requirements.append(eval(i))
			elif '#' in i:
				formated_requirements.append(re.sub('#', '.', i))
			else:
				formated_requirements.append(i)
		formated_stream_rule.append(formated_requirements)
		formated_stream_rules.append(formated_stream_rule)
	rules[stream] = formated_stream_rules

	if debug : print(rules)


	print(f"\nCompleted:")
	CompletedSubjects = getCompletedSubjects(db, zid)

	total_achieved_uoc  = 0
	for subjectInfo in CompletedSubjects:
		[CourseCode, Term, SubjectTitle, Mark, Grade, UOC] = subjectInfo

		# printable strings
		Mark_str = "  -" if Mark == None else f"{Mark:>3}"
		
		suitable_rules = []
		# check stream rules
		for stream_rule in rules[stream]:
			for requirement in stream_rule[-1]:
				if type(requirement) == list:
					for code_str in requirement:
						# result has all possible results of regular expression
						result = re.findall(code_str, CourseCode)
						if result:
							for i in result:
								# result_info : [rule_name, min_req, max_rea, course_code]
								result_info =  stream_rule[:-1] + [CourseCode]
								# append to suitable_list
								suitable_rules.append({stream_rule[1]: result_info})

				elif type(requirement) == str and re.match(requirement, CourseCode):
					# result_info : [rule_name, min_req, max_rea, course_code]
					result_info =  stream_rule[:-1] + [CourseCode]
					# append to suitable_list
					suitable_rules.append({stream_rule[1]: result_info})


		# check program rules
		for program_rule in rules[program]:
			for requirement in program_rule[-1]:
				if type(requirement) == list:
					for code_str in requirement:
						# result has all possible results of regular expression
						result = re.findall(code_str, CourseCode)
						if result:
							for i in result:
								# result_info : [rule_name, min_req, max_rea, course_code]
								result_info =  program_rule[:-1] + [CourseCode]
								# append to suitable_list
								suitable_rules.append({program_rule[1]: result_info})

				elif type(requirement) == str and re.match(requirement, CourseCode):
					# result_info : [rule_name, min_req, max_rea, course_code]
					result_info =  program_rule[:-1] + [CourseCode]
					# append to suitable_list
					suitable_rules.append({program_rule[1]: result_info})

		if debug : print("\n\n")
		if debug : print(suitable_rules)
		if debug : print(len(suitable_rules))

		Toward_list = []
		for suitable_rule in suitable_rules:
			if 'CC' in suitable_rule:
				Toward_list.append(suitable_rule['CC'][0])
		if Toward_list == []:
			for suitable_rule in suitable_rules:
				if 'PE' in suitable_rule:
					Toward_list.append(suitable_rule['PE'][0])
		if Toward_list == []:
			for suitable_rule in suitable_rules:
				if 'FE' in suitable_rule:
					Toward_list.append(suitable_rule['FE'][0])
		if Toward_list == []:
			for suitable_rule in suitable_rules:
				if 'GE' in suitable_rule:
					Toward_list.append(suitable_rule['GE'][0])
		if debug : print(Toward_list)
		Toward_str = " + ".join(Toward_list)
		if debug : print(Toward_str)

		# uoc calculate
		if Grade in Grade_in_UOC and Toward_list != []:
			total_achieved_uoc += UOC

		if Grade in Print_Xuoc:
			if Toward_str == "":
				print(f"{CourseCode} {Term} {SubjectTitle:<32s}" + Mark_str + f" {Grade:2s}  0uoc does not satisfy any rule")
			else:
				print(f"{CourseCode} {Term} {SubjectTitle:<32s}" + Mark_str + f" {Grade:2s}  {UOC:2d}uoc " + Toward_str)
		elif Grade in Print_fail:
			print(f"{CourseCode} {Term} {SubjectTitle:<32s}" + Mark_str + " " + f"{Grade:2s}   fail does not count")

		# remove course in rules[stream]
		for rule in rules[stream][:]:
			rules[stream].remove(rule)
			[rule_name, rule_type, min_req, max_req, courses] = rule
			for course in courses[:]:
				if type(course) == list and CourseCode in course:
					courses.remove(course)
					if min_req != None and min_req >= UOC: min_req -= UOC
					if max_req != None and max_req >= UOC: max_req -= UOC
				elif type(course) == str and re.match(course, CourseCode):
					courses.remove(course)
					if min_req != None and min_req >= UOC: min_req -= UOC
					if max_req != None and max_req >= UOC: max_req -= UOC
			rule = [rule_name, rule_type, min_req, max_req, courses]
			rules[stream].append(rule)

		# remove course in rules[program]
		for rule in rules[program][:]:
			rules[program].remove(rule)
			[rule_name, rule_type, min_req, max_req, courses] = rule
			for course in courses[:]:
				if type(course) == list and CourseCode in course:
					courses.remove(course)
					if min_req != None: min_req -= UOC
					if max_req != None: max_req -= UOC
				elif type(course) == str and re.match(course, CourseCode):
					courses.remove(course)
					if min_req != None: min_req -= UOC
					if max_req != None: max_req -= UOC
			rule = [rule_name, rule_type, min_req, max_req, courses]
			rules[program].append(rule)

		# drop rule when
		# 1. [min_req, max_req] = [0, None], []

		if debug : print("\n")
		if debug : print(rules)

	# print the total uoc
	print(f"UOC = {total_achieved_uoc} so far")

except Exception as err:
	print("DB error: ", err)
finally:
	if db:
		db.close()

